/**
 * @file Firebase Security Rules for Firestore.
 *
 * @core_philosophy This ruleset prioritizes secure authorization and access control,
 *                  while remaining flexible on data shapes to allow rapid prototyping.
 *                  It enforces strict ownership and shared access patterns based on
 *                  authenticated user identities. Data validation is minimized to only
 *                  essential checks for relational integrity and authorization.
 *
 * @data_structure
 * - `/posts/{postId}`: Public posts created by users.
 * - `/comments/{commentId}`: Comments on posts.
 * - `/users/{userId}`: Public user profiles.
 * - `/bottles/{bottleId}`: Messages in bottles.
 * - `/wallMessages/{messageId}`: Public messages on the community wall.
 * - `/friendRequests/{requestId}`: Friend requests between users.
 * - `/conversations/{conversationId}`: Metadata for private conversations.
 * - `/conversations/{conversationId}/messages/{messageId}`: Messages within a conversation.
 *
 * @key_security_decisions
 * - User listing is generally disallowed to protect privacy.
 * - Public read access is granted to certain top-level collections (e.g., `posts`, `wallMessages`)
 *   while restricting write access to authenticated owners.
 * - Shared access to conversations is managed through the `participantIds` array on the conversation document.
 * - Data validation is limited to ownership and relational integrity checks during `create` and `update` operations.
 *
 * @denormalization_for_authorization
 * - The `posts` collection requires an `authorId` field to enforce owner-only write access.
 * - The `comments` collection requires a `postId` and `authorId` field.
 * - The `conversations` collection uses `participantIds` to determine who can read and write messages.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the current user is signed in.
     * @return {bool} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the current user is the owner of the resource.
     * @param {string} userId - The user ID to compare against the request's authentication UID.
     * @return {bool} True if the user is the owner, false otherwise.
     * @example isOwner('someUserId') returns true if request.auth.uid == 'someUserId'.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the current user is the owner of the existing resource.
     * @param {string} userId - The user ID to compare against the resource's data and the request's authentication UID.
     * @return {bool} True if the user is the owner and the resource exists, false otherwise.
     * @example isExistingOwner('someUserId') returns true if request.auth.uid == 'someUserId' and the resource exists.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Allows anyone to read posts, but only the owner to create, update, or delete them.
     * @path /posts/{postId}
     * @allow (get, list): if true
     * @allow (create): if request.auth.uid == request.resource.data.authorId
     * @allow (update, delete): if resource.data.authorId == request.auth.uid
     * @deny (create): if request.resource.data.authorId == null
     * @deny (update, delete): if resource == null
     * @principle Public read access with owner-only writes, enforcing the resource exists.
     */
    match /posts/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows anyone to read comments, but only the owner to create, update, or delete them.
     * @path /comments/{commentId}
     * @allow (get, list): if true
     * @allow (create): if request.auth.uid == request.resource.data.authorId
     * @allow (update, delete): if resource.data.authorId == request.auth.uid
     * @deny (create): if request.resource.data.authorId == null
     * @deny (update, delete): if resource == null
     * @principle Public read access with owner-only writes, enforcing the resource exists.
     */
    match /comments/{commentId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows a user to create their own profile and update it. No listing allowed.
     * @path /users/{userId}
     * @allow (get): if true
     * @allow (create): if request.auth.uid == userId
     * @allow (update, delete): if request.auth.uid == userId && resource != null
     * @deny (list): if true
     * @principle User-owned data, enforcing the resource exists.
     */
    match /users/{userId} {
      allow get: if true;
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows anyone to read bottles, but only the owner to create, update, or delete them.
     * @path /bottles/{bottleId}
     * @allow (get, list): if true
     * @allow (create): if request.auth.uid == request.resource.data.authorId
     * @allow (update, delete): if resource.data.authorId == request.auth.uid
     * @deny (create): if request.resource.data.authorId == null
     * @deny (update, delete): if resource == null
     * @principle Public read access with owner-only writes, enforcing the resource exists.
     */
    match /bottles/{bottleId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows anyone to read wall messages, but only the owner to create, update, or delete them.
     * @path /wallMessages/{messageId}
     * @allow (get, list): if true
     * @allow (create): if request.auth.uid == request.resource.data.authorId
     * @allow (update, delete): if resource.data.authorId == request.auth.uid
     * @deny (create): if request.resource.data.authorId == null
     * @deny (update, delete): if resource == null
     * @principle Public read access with owner-only writes, enforcing the resource exists.
     */
    match /wallMessages/{messageId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows users to create, update, delete their own friend requests.
     * Only the recipient can read the friend request.
     * @path /friendRequests/{requestId}
     * @allow (get): if request.auth.uid == resource.data.toId
     * @allow (list): if request.auth.uid == resource.data.toId
     * @allow (create): if request.auth.uid == request.resource.data.fromId
     * @allow (update): if request.auth.uid == resource.data.fromId && resource != null
     * @allow (delete): if request.auth.uid == resource.data.fromId && resource != null
     * @deny (create): if request.resource.data.fromId == null
     * @deny (update, delete): if resource == null
     * @principle User-owned data with read access only to the recipient, enforcing the resource exists.
     */
    match /friendRequests/{requestId} {
        allow get, list: if isSignedIn() && request.auth.uid == resource.data.toId;
        allow create: if isSignedIn() && request.auth.uid == request.resource.data.fromId;
        allow update: if isSignedIn() && request.auth.uid == resource.data.fromId && resource != null;
        allow delete: if isSignedIn() && request.auth.uid == resource.data.fromId && resource != null;
    }

    /**
     * @description Allows participants to read and manage conversations.
     * @path /conversations/{conversationId}
     * @allow (get, list): if request.auth.uid in resource.data.participantIds
     * @allow (create): if request.resource.data.participantIds.hasAll([request.auth.uid])
     * @allow (update): if request.auth.uid in resource.data.participantIds && resource != null
     * @allow (delete): if request.auth.uid in resource.data.participantIds && resource != null
     * @deny (create): if !request.resource.data.participantIds is list
     * @deny (update, delete): if resource == null
     * @principle Shared access based on participantIds, enforcing the resource exists.
     */
    match /conversations/{conversationId} {
      allow get, list: if isSignedIn() && request.auth.uid in resource.data.participantIds;
      allow create: if isSignedIn() && request.resource.data.participantIds.hasAll([request.auth.uid]);
      allow update: if isSignedIn() && request.auth.uid in resource.data.participantIds && resource != null;
      allow delete: if isSignedIn() && request.auth.uid in resource.data.participantIds && resource != null;
    }

    /**
     * @description Allows participants to manage messages within a conversation.
     * @path /conversations/{conversationId}/messages/{messageId}
     * @allow (get, list): if get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds.hasAny([request.auth.uid])
     * @allow (create): if isSignedIn() && get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds.hasAny([request.auth.uid]) && request.resource.data.senderId == request.auth.uid
     * @allow (update): if isSignedIn() && get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds.hasAny([request.auth.uid]) && request.resource.data.senderId == request.auth.uid && resource != null
     * @allow (delete): if isSignedIn() && get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds.hasAny([request.auth.uid]) && request.resource.data.senderId == request.auth.uid && resource != null
     * @deny (create, update, delete): if resource == null
     * @principle Shared access based on conversation's participantIds, enforcing the resource exists.
     */
    match /conversations/{conversationId}/messages/{messageId} {
      allow get, list: if isSignedIn() && get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds.hasAny([request.auth.uid]);
      allow create: if isSignedIn() && get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds.hasAny([request.auth.uid]) && request.resource.data.senderId == request.auth.uid;
      allow update: if isSignedIn() && get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds.hasAny([request.auth.uid]) && request.resource.data.senderId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds.hasAny([request.auth.uid]) && request.resource.data.senderId == request.auth.uid && resource != null;
    }
  }
}