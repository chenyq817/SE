/**
 * @file Firestore Security Rules for the application.
 *
 * @core_philosophy This ruleset prioritizes user data protection and access control. It enforces strict ownership for user-related data,
 * and provides public read access for community-generated content. All write operations require authentication.
 *
 * @data_structure
 * - `/users/{userId}`: Stores public user profile information. Access is restricted to the owner (self-creation allowed) or through verified friend actions.
 * - `/posts/{postId}`: Stores social posts. Read access is public, but write access is restricted to the owner.
 * - `/posts/{postId}/comments/{commentId}`: Stores comments for each post. Write access is restricted to the comment creator.
 * - `/chats/{chatId}`: Stores chat sessions. Access is restricted to participants.
 * - `/chats/{chatId}/messages/{messageId}`: Stores chat messages. Access is restricted to chat participants.
 * - `/wallMessages/{messageId}`: Stores public wall messages.
 *
 * @key_security_decisions
 * - User listing is allowed for authenticated users, but write access is highly restricted.
 * - Public read access is granted for posts and wall messages.
 * - All write operations require authentication and are scoped to the user's role (owner, participant).
 *
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the current user is signed in.
     * @return {bool} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user ID matches the provided user ID.
     * @param {string} userId The user ID to compare against the authenticated user's ID.
     * @return {bool} True if the user IDs match, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the document being accessed already exists.
     * @return {bool} True if the document exists, false otherwise.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * @description Checks if the user is the owner of an existing document.
     * @param {string} userId The user ID to check against the authenticated user.
     * @return {bool} True if the user is the owner of an existing document.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }
    
    /**
     * @description Validates the data for a user profile update.
     * @param {map} data The data being submitted in the request.
     * @return {bool} True if the data types are correct.
     */
    function hasValidProfileData(data) {
       return data.displayName is string &&
              data.displayName_lowercase is string &&
              data.avatarId is string;
    }

    /**
     * @description Validates the sending of a friend request.
     * Checks that a user is adding themselves to the target's `friendRequestsReceived` list,
     * and only that field is changed.
     * @return {bool} True if the update is a valid friend request.
     */
    function canSendFriendRequest() {
      let incomingData = request.resource.data;
      let existingData = resource.data;
      let affectedKeys = incomingData.diff(existingData).affectedKeys();

      return isSignedIn() &&
             affectedKeys.hasOnly(['friendRequestsReceived']) &&
             incomingData.friendRequestsReceived == existingData.friendRequestsReceived.append(request.auth.uid);
    }
    
    /**
     * @description Validates the acceptance of a friend request.
     * This rule is checked on the document of the user who *sent* the request.
     * It ensures the user accepting the request is being added to the sender's `friendIds` list
     * and removed from their `friendRequestsSent` list.
     * @return {bool} True if the update is a valid friend request acceptance.
     */
    function canAcceptFriendRequest() {
        let incomingData = request.resource.data;
        let existingData = resource.data;
        let affectedKeys = incomingData.diff(existingData).affectedKeys();

        return isSignedIn() &&
               affectedKeys.hasOnly(['friendIds', 'friendRequestsSent']) &&
               incomingData.friendIds == existingData.friendIds.append(request.auth.uid) &&
               incomingData.friendRequestsSent == existingData.friendRequestsSent.removeAll([request.auth.uid]);
    }

    /**
     * @description Validates declining a friend request or removing a friend.
     * This rule is checked on the document of the other user involved.
     * It allows the current user to trigger their removal from the other user's relevant list.
     * Case 1 (Decline): Current user removes themself from other user's 'friendRequestsSent' list.
     * Case 2 (Remove): Current user removes themself from other user's 'friendIds' list.
     * @return {bool} True if the update is a valid decline or removal.
     */
    function canDeclineOrRemoveFriend() {
        let incomingData = request.resource.data;
        let existingData = resource.data;
        let affectedKeys = incomingData.diff(existingData).affectedKeys();

        let isDeclining = affectedKeys.hasOnly(['friendRequestsSent']) &&
                          incomingData.friendRequestsSent == existingData.friendRequestsSent.removeAll([request.auth.uid]);
        
        let isRemoving = affectedKeys.hasOnly(['friendIds']) &&
                         incomingData.friendIds == existingData.friendIds.removeAll([request.auth.uid]);

        return isSignedIn() && (isDeclining || isRemoving);
    }


    match /users/{userId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && isOwner(userId) && hasValidProfileData(request.resource.data);
      allow delete: if false; // Deleting users should be handled server-side.

      // A user can update a document if:
      // 1. They are the owner (updating their own profile).
      // 2. They are sending a friend request to this user.
      // 3. They are accepting a friend request from this user.
      // 4. They are declining a request from or removing this user as a friend.
      allow update: if isExistingOwner(userId)
                    || canSendFriendRequest()
                    || canAcceptFriendRequest()
                    || canDeclineOrRemoveFriend();
    }

    match /posts/{postId} {
      allow read: if true;
      allow create: if isSignedIn() && isOwner(request.resource.data.authorId);
      allow update, delete: if isSignedIn() && isOwner(resource.data.authorId);
      
      match /comments/{commentId} {
        allow read: if true;
        allow create: if isSignedIn() && isOwner(request.resource.data.authorId);
        allow update, delete: if isSignedIn() && isOwner(resource.data.authorId);
      }
    }

    match /wallMessages/{messageId} {
      allow read: if true;
      allow create: if isSignedIn() && isOwner(request.resource.data.authorId);
      allow update, delete: if isSignedIn() && isOwner(resource.data.authorId);
    }
    
    match /chats/{chatId} {
      allow read, create: if isSignedIn() && request.auth.uid in request.resource.data.participantIds;
      allow update: if isSignedIn() && request.auth.uid in resource.data.participantIds;

      match /messages/{messageId} {
        allow read, create: if isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds;
      }
    }
  }
}
