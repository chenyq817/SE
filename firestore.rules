/**
 * @fileoverview Firestore Security Rules for Prototyping.
 *
 * Core Philosophy:
 * This ruleset prioritizes rapid prototyping by focusing on authorization and relationship enforcement, while relaxing data validation. It enforces a basic level of security, ensuring that only authorized users can access specific data. Data shape validation is minimized to allow for flexible schema changes during development.
 *
 * Data Structure:
 * - /posts/{postId}: Stores all campus posts. Publicly readable, but write-protected to enforce ownership.
 * - /comments/{commentId}: Stores comments on posts. Publicly readable, but write-protected to enforce ownership.
 *
 * Key Security Decisions:
 * - Users are not allowed to list all users.
 * - All read operations (`get`, `list`) are explicitly defined. There are no implicit open reads.
 * - All write operations (`create`, `update`, `delete`) are explicitly authorized. There are no open writes.
 *
 * Denormalization for Authorization:
 *  - The rules assume that the `authorId` field is present in both `posts` and `comments` collections to check ownership, ensuring that only the author can modify/delete their content.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Grants read access to all posts, but restricts write access to the author of the post.
     * @path /databases/{database}/documents/posts/{postId}
     * @allow (get, list): Any user can read any post.
     * @allow (create): Only an authenticated user can create a post, and the authorId must match their UID.
     * @allow (update, delete): Only the author of the post can update or delete it.
     * @deny (create): An unauthenticated user cannot create a post.
     * @deny (update, delete): A user who is not the author cannot update or delete the post.
     * @principle Allows public read access while enforcing ownership for write access.
     */
    match /posts/{postId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.authorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Grants read access to all comments, but restricts write access to the author of the comment.
     * @path /databases/{database}/documents/comments/{commentId}
     * @allow (get, list): Any user can read any comment.
     * @allow (create): Only an authenticated user can create a comment, and the authorId must match their UID.
     * @allow (update, delete): Only the author of the comment can update or delete it.
     * @deny (create): An unauthenticated user cannot create a comment.
     * @deny (update, delete): A user who is not the author cannot update or delete the comment.
     * @principle Allows public read access while enforcing ownership for write access.
     */
    match /comments/{commentId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.authorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
  }
}