/**
 * @file Firestore Security Rules for the application.
 *
 * @core_philosophy This ruleset prioritizes user data protection and access control. It enforces strict ownership for user-related data,
 * and provides public read access for community-generated content. All write operations require authentication.
 *
 * @data_structure
 * - `/users/{userId}`: Stores public user profile information. Access is restricted to the owner (self-creation allowed).
 * - `/posts/{postId}`: Stores social posts. Read access is public, but write access is restricted to the owner.
 * - `/posts/{postId}/comments/{commentId}`: Stores comments for each post. Write access is restricted to the comment creator.
 * - `/chats/{chatId}`: Stores metadata for a private chat session between users.
 * - `/chats/{chatId}/messages/{messageId}`: Stores the actual messages for a chat session.
 * - `/wallMessages/{messageId}`: Stores public wall messages.
 *
 * @key_security_decisions
 * - User listing is generally disallowed for scalability, but enabled here for the "find friends" feature.
 * - Public read access is granted for posts and wall messages.
 * - All write operations require authentication.
 *
 * @denormalization_for_authorization N/A
 *
 * @structural_segregation N/A
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the current user is signed in.
     * @return {bool} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user ID matches the provided user ID.
     * @param {string} userId The user ID to compare against the authenticated user's ID.
     * @return {bool} True if the user IDs match, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of an existing document.
     * @param {string} userId The user ID to compare against the authenticated user's ID.
     * @return {bool} True if the user IDs match and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && exists(/databases/$(database)/documents/users/$(userId));
    }
    
    /**
     * @description Checks if an update to a user document is a valid friend request operation.
     * This function ensures that the only change being made is the addition of the current user's UID
     * to the target user's 'friendRequestsReceived' list.
     * @param {string} targetUserId The UID of the user whose document is being updated.
     * @return {bool} True if the update is a valid friend request, false otherwise.
     */
    function isValidFriendRequest(targetUserId) {
        let incomingData = request.resource.data;
        let existingData = resource.data;
        let diff = incomingData.diff(existingData);

        return isSignedIn() &&
               isOwner(targetUserId) == false && // Cannot send a request to yourself
               diff.affectedKeys().hasOnly(['friendRequestsReceived']) && // Only this field can change
               incomingData.friendRequestsReceived is list &&
               incomingData.friendRequestsReceived.size() == existingData.friendRequestsReceived.size() + 1 && // List grows by exactly 1
               incomingData.friendRequestsReceived.hasAll(existingData.friendRequestsReceived) && // All old items must still be there
               incomingData.friendRequestsReceived.hasAny([request.auth.uid]); // The new item must be the sender's UID
    }


    match /users/{userId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn(); // Necessary for the "find friends" feature
      allow create: if isSignedIn() && isOwner(userId);
      allow delete: if isOwner(userId);

      // Allow updates if the user is the owner (editing their own profile)
      // OR if the update is a valid friend request operation targeting this user.
      allow update: if isOwner(userId) || isValidFriendRequest(userId);
    }

    match /posts/{postId} {
      allow read: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isSignedIn() && resource.data.authorId == request.auth.uid;

      match /comments/{commentId} {
        allow read: if true;
        allow create: if isSignedIn(); // Allow any signed-in user to comment
        allow update, delete: if isSignedIn() && resource.data.authorId == request.auth.uid;
      }
    }
    
    match /chats/{chatId} {
      // Allow read/write only if the user is a participant in the chat.
      allow read, write: if isSignedIn() && request.auth.uid in resource.data.participantIds;
      // Allow creation if the user is one of the participants.
      allow create: if isSignedIn() && request.auth.uid in request.resource.data.participantIds;
      
      match /messages/{messageId} {
        // Allow read only if the user is a participant of the parent chat.
        allow read: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds.hasAny([request.auth.uid]);
        // Allow create only if the sender is the current user and they are a participant.
        allow create: if isSignedIn() && 
                      request.resource.data.senderId == request.auth.uid &&
                      get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds.hasAny([request.auth.uid]);
        // Disallow updates and deletes for individual messages to maintain chat integrity.
        allow update, delete: if false;
      }
    }

    match /wallMessages/{messageId} {
      allow read: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isSignedIn() && resource.data.authorId == request.auth.uid;
    }
  }
}