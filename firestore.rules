/**
 * @fileoverview Firestore Security Rules for the campus social circle application.
 *
 * Core Philosophy:
 * This ruleset prioritizes user data protection and access control, ensuring that users can only read and modify their own data unless explicitly granted shared access. Public data (e.g., wall messages, posts) is readable by all but writable only by authenticated users.
 *
 * Data Structure:
 * - /posts/{postId}: Public posts, readable by all, writable by the author.
 * - /posts/{postId}/comments/{commentId}: Comments on posts, readable by all, writable by the author.
 * - /users/{userId}: User profiles, readable and writable only by the user.
 * - /wallMessages/{messageId}: Public wall messages, readable by all, writable by authenticated users.
 * - /chats/{chatId}: Private chats, accessible only to participants.
 * - /chats/{chatId}/messages/{messageId}: Messages within a chat, accessible only to chat participants.
 *
 * Key Security Decisions:
 * - User profiles are private and only accessible to the user themselves.
 * - Listing all users is disallowed for privacy.
 * - Chats and chat messages are restricted to participants only.
 * - Public data (posts, wall messages) is readable by all, but write access is controlled.
 *
 * Denormalization for Authorization:
 * - Chats store `participantIds` and `participantInfo` directly on the document for efficient authorization. This avoids costly `get()` calls to other collections to determine chat membership.
 *
 * Structural Segregation:
 * - Public posts and private user profiles are stored in separate collections to simplify access control and optimize query performance.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the requesting user is the owner of the resource.
     * @param {string} userId - The user ID to compare against the request's auth UID.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the requesting user is the owner of the resource and if the resource exists.
     * @param {string} userId - The user ID to compare against the request's auth UID.
     * @return {boolean} True if the user is the owner and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
        return (isOwner(userId) && resource != null);
    }

    /**
     * @description Checks if the requesting user is a participant in the chat.
     * @param {array} participantIds - An array of user IDs who are participants in the chat.
     * @return {boolean} True if the user is a participant, false otherwise.
     */
    function isChatParticipant(participantIds) {
      return isSignedIn() && participantIds.hasAny([request.auth.uid]);
    }

    /**
     * @description Rules for posts. Anyone can read, but only the author can create, update, or delete.
     * @path /posts/{postId}
     * @allow (get, list): Anyone can read posts.
     * @allow (create): An authenticated user can create a post if they are the author. Example: request.auth.uid == 'user123' and request.resource.data.authorId == 'user123'.
     * @allow (update, delete): Only the author of the post can update or delete it. Example: request.auth.uid == resource.data.authorId.
     * @deny (create): An unauthenticated user tries to create a post.
     * @deny (update, delete): A user tries to update or delete a post they didn't author.
     * @principle Allows public read access while enforcing ownership for write access to posts.
     */
    match /posts/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Rules for comments on posts. Anyone can read, but only the author can create, update, or delete.
     * @path /posts/{postId}/comments/{commentId}
     * @allow (get, list): Anyone can read comments on posts.
     * @allow (create): An authenticated user can create a comment if they are the author. Example: request.auth.uid == 'user123' and request.resource.data.authorId == 'user123'.
     * @allow (update, delete): Only the author of the comment can update or delete it. Example: request.auth.uid == resource.data.authorId.
     * @deny (create): An unauthenticated user tries to create a comment.
     * @deny (update, delete): A user tries to update or delete a comment they didn't author.
     * @principle Allows public read access while enforcing ownership for write access to comments.
     */
    match /posts/{postId}/comments/{commentId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid && request.resource.data.postId == postId;
      allow update, delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Rules for user profiles. Only the user can read or write their own profile.
     * @path /users/{userId}
     * @allow (get): The user can read their own profile. Example: request.auth.uid == 'user123'.
     * @allow (create): A user can create their own profile if the userId matches their auth.uid. Example: request.auth.uid == 'user123'.
     * @allow (update, delete): The user can update or delete their own profile. Example: request.auth.uid == 'user123'.
     * @deny (get, create, update, delete): Another user tries to read or modify this profile.
     * @deny (list): Listing all users is disallowed for privacy.
     * @principle Enforces strict user-ownership model for profile data.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for wall messages. Anyone can read, but only authenticated users can create.
     * @path /wallMessages/{messageId}
     * @allow (get, list): Anyone can read wall messages.
     * @allow (create): An authenticated user can create a wall message.
     * @deny (create): An unauthenticated user tries to create a wall message.
     * @deny (update, delete): No one can update or delete wall messages.
     * @principle Allows public read access but restricts write access to authenticated users for wall messages.
     */
    match /wallMessages/{messageId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update, delete: if false;
    }

    /**
     * @description Rules for chats. Only participants can read or write chat metadata.
     * @path /chats/{chatId}
     * @allow (get): A participant can get chat metadata.
     * @allow (list): A participant can list chats they are a part of.
     * @allow (create): Only participants can create a chat if their ID is present in the participantIds array.
     * @allow (update, delete): Only participants can update or delete a chat.
     * @deny (get, create, update, delete): A non-participant attempts to access the chat.
     * @principle Enforces shared access between chat participants for chat metadata.
     */
    match /chats/{chatId} {
      allow get: if isChatParticipant(resource.data.participantIds);
      allow list: if isSignedIn(); // Allowing listing to signed-in users, the query must filter the chats based on user id in the client code.
      allow create: if isSignedIn() && request.resource.data.participantIds.hasAny([request.auth.uid]);
      allow update: if isChatParticipant(resource.data.participantIds) && resource != null;
      allow delete: if isChatParticipant(resource.data.participantIds) && resource != null;
    }

    /**
     * @description Rules for chat messages. Only participants can read or write messages in a chat.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get, list): A participant can read messages in a chat.
     * @allow (create): A participant can create a message in a chat.
     * @allow (update, delete): No one can update or delete messages.
     * @deny (get, create, update, delete): A non-participant attempts to access the chat messages.
     * @principle Enforces shared access between chat participants for chat messages.
     */
    match /chats/{chatId}/messages/{messageId} {
      allow get, list: if isSignedIn() && get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds.hasAny([request.auth.uid]);
      allow create: if isSignedIn() && request.resource.data.chatId == chatId && get(/databases/$(database)/documents/chats/$(chatId)).data.participantIds.hasAny([request.auth.uid]);
      allow update, delete: if false;
    }
  }
}